diff --git a/src/cpu/pred/BranchPredictor.py b/src/cpu/pred/BranchPredictor.py
index d18ca3f821..6d9ca1c45c 100644
--- a/src/cpu/pred/BranchPredictor.py
+++ b/src/cpu/pred/BranchPredictor.py
@@ -82,6 +82,13 @@ class LocalBP(BranchPredictor):
     localPredictorSize = Param.Unsigned(2048, "Size of local predictor")
     localCtrBits = Param.Unsigned(2, "Bits per counter")
 
+class GShareBP(BranchPredictor):
+    type = "GShareBP"
+    cxx_class = "gem5::branch_prediction::GShareBP"
+    cxx_header = "cpu/pred/gshare.hh"
+
+    globalPredictorSize = Param.Unsigned(8192, "Size of global predictor")
+    globalCtrBits = Param.Unsigned(2, "Bits per counter")
 
 class TournamentBP(BranchPredictor):
     type = "TournamentBP"
diff --git a/src/cpu/pred/SConscript b/src/cpu/pred/SConscript
index f4b6870ec5..b4da2a82b7 100644
--- a/src/cpu/pred/SConscript
+++ b/src/cpu/pred/SConscript
@@ -41,11 +41,12 @@ SimObject('BranchPredictor.py', sim_objects=[
     'MultiperspectivePerceptronTAGE', 'MPP_StatisticalCorrector_64KB',
     'MultiperspectivePerceptronTAGE64KB', 'MPP_TAGE_8KB',
     'MPP_LoopPredictor_8KB', 'MPP_StatisticalCorrector_8KB',
-    'MultiperspectivePerceptronTAGE8KB'])
+    'MultiperspectivePerceptronTAGE8KB', 'GShareBP'])
 
 DebugFlag('Indirect')
 Source('bpred_unit.cc')
 Source('2bit_local.cc')
+Source('gshare.cc')
 Source('btb.cc')
 Source('simple_indirect.cc')
 Source('indirect.cc')
diff --git a/src/cpu/pred/gshare.cc b/src/cpu/pred/gshare.cc
new file mode 100644
index 0000000000..9c33306b8d
--- /dev/null
+++ b/src/cpu/pred/gshare.cc
@@ -0,0 +1,47 @@
+#include "cpu/pred/gshare.hh"
+
+#include "base/intmath.hh"
+#include "base/trace.hh"
+#include "debug/Fetch.hh"
+
+namespace gem5
+{
+
+namespace branch_prediction
+{
+
+GShareBP::GShareBP(const GShareBPParams &params)
+    : BPredUnit(params)
+{
+    
+}
+
+void GShareBP::btbUpdate(ThreadID tid, Addr branch_addr, void * &bp_history)
+{
+
+}
+
+bool GShareBP::lookup(ThreadID tid, Addr branch_addr, void * &bp_history)
+{
+    return true;
+}
+
+void GShareBP::uncondBranch(ThreadID tid, Addr branch_addr, void * &bp_history)
+{
+
+}
+
+void GShareBP::update(ThreadID tid, Addr branch_addr, bool taken, 
+					  void *bp_history, bool squashed, 
+					  const StaticInstPtr & inst, Addr corrTarget)
+{
+
+}
+
+void GShareBP::squash(ThreadID tid, void *bp_history) 
+{
+
+}
+
+} // namespace branch_prediction
+} // namespace gem5
diff --git a/src/cpu/pred/gshare.hh b/src/cpu/pred/gshare.hh
new file mode 100644
index 0000000000..09a69add4c
--- /dev/null
+++ b/src/cpu/pred/gshare.hh
@@ -0,0 +1,84 @@
+#ifndef __CPU_PRED_GSHARE_PRED_HH__
+#define __CPU_PRED_GSHARE_PRED_HH__
+
+#include <vector>
+
+#include "base/types.hh"
+#include "cpu/pred/bpred_unit.hh"
+#include "base/sat_counter.hh"
+#include "params/GShareBP.hh"
+
+namespace gem5
+{
+
+namespace branch_prediction
+{
+
+/**
+ * Implements a gshare predictor, in which global history is XORed against
+ * bits from the PC. It uses the branch history to index into a table of
+ * counters. Global history is speculatively updated, and corrected during
+ * a squash.
+ */
+class GShareBP : public BPredUnit
+{
+  public:
+    /**
+     * Default branch predictor constructor.
+     */
+    GShareBP(const GShareBPParams &params);
+    /**
+     * Looks up the given address in the branch predictor and returns
+     * a true/false value as to whether it is taken.  Also creates a
+     * BPHistory object to store any state it will need on squash/update.
+     * @param branch_addr The address of the branch to look up.
+     * @param bp_history Pointer that will be set to the BPHistory object.
+     * @return Whether or not the branch is taken.
+     */
+    bool lookup(ThreadID tid, Addr branch_addr, void * &bp_history);
+
+    /**
+     * Records that there was an unconditional branch, and modifies
+     * the bp history to point to an object that has the previous
+     * global history stored in it.
+     * @param bp_history Pointer that will be set to the BPHistory object.
+     */
+    void uncondBranch(ThreadID tid, Addr branch_addr, void * &bp_history);
+
+    /**
+     * Updates the branch predictor to Not Taken if a BTB entry is
+     * invalid or not found.
+     * @param branch_addr The address of the branch to look up.
+     * @param bp_history Pointer to any bp history state.
+     * @return Whether or not the branch is taken.
+     */
+
+    void btbUpdate(ThreadID tid, Addr branch_addr, void * &bp_history);
+
+    /**
+     * Updates the branch predictor with the actual result of a branch.
+     * @param branch_addr The address of the branch to update.
+     * @param taken Whether or not the branch was taken.
+     * @param bp_history Pointer to the BPHistory object that was created
+     * when the branch was predicted.
+     * @param squashed is set when this function is called during a squash
+     * operation.
+     */
+    void update(ThreadID tid, Addr branch_addr, bool taken, void *bp_history,
+                bool squashed, const StaticInstPtr & inst, Addr corrTarget);
+
+    /**
+     * Restores the global branch history on a squash.
+     * @param bp_history Pointer to the BPHistory object that has the
+     * previous global branch history in it.
+     */
+    void squash(ThreadID tid, void *bp_history);
+
+  private:
+
+};
+
+}; // namespace branch_prediction
+}; // namespace gem5
+
+#endif // __CPU_PRED_GSHARE_PRED_HH__
